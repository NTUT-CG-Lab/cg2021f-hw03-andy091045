<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - loaders - MMD loader</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <style>
      body {
        background-color: #fff;
        color: #444;
      }

      a {
        color: #08f;
      }
    </style>
  </head>

  <body>
    <div id="info"></div>

    <script src="js/libs/ammo.wasm.js"></script>
    <script src="scoreoutputer.min.js"></script>
    <script>
      // 建構子 ScoreOutputer 接受一個字串，該字串為 csv 的檔案名稱
      // 以下面範例，檔名就為 "109598105(總分: 6).csv"
      var so = new ScoreOutputer("109598105");
      so.installCSS(function () {
        // 安裝 bootstrap 的 css，如果在 html 上方引用 bootstrap 5.1.1 的話就不用使用 installCSS ，注意一定要 bootstrap css 5.1.1 版
        // installCSS 接收一個 callback 當作參數，作為成功安裝 bootstrap css 的回呼函式

        //加入項目，分數，完成狀況
        //第一個參數為 項目名稱
        //第2個參數為 項目分數
        //第3個參數為 完成狀況，有完成 true/未完成 false
        //有幾個項目就呼叫幾個 addChild
        //addChild 要比 renderModal 先呼叫
        so.addChild("繪製出 5 個畫面", 1, true);
        so.addChild("回答問題", 1, true);
        so.addChild("可按鍵選擇上 / 下一隻角色", 1, true);
        so.addChild("讀取作業 2 儲存的座標點在眼睛上繪製出分割線", 1, true);
        so.addChild("可選擇當下控制哪個虹膜", 1, true);
        so.addChild("按滑鼠左鍵控制虹膜移動，右鍵停止", 2, true);
        so.addChild("複製參數至對應目標參數", 2, true);
        so.addChild("可儲存虹膜轉動角度", 1, true);

        //產生自評表，參數如下所示
        so.renderModal(
          //1. 自評表插入位置 (預設 document.body)
          document.body,
          //2. 自評表背景 (預設紅色)
          "rgba(100,45,58,1)",
          //3. 自評表文字顏色 (預設白色)
          "white",
          //4. 自評表文字大小 (預設 14pt)
          "15pt",
          //5. 自評表 checkbox 文字大小 (預設多少忘了)
          "15px",
          //6. 自評表標題 (預設 "自我評分表")
          (dialogTitle = "自我評分表")
        );

        //設定下載按鈕 <-- 一定要呼叫這個函數，不然沒有下載功能
        so.installDownloadBtn();

        //產生 "開啟自評表按鈕"
        so.renderBtn(
          //自評表按鈕插入位置
          document.querySelector("#info"),
          //自評表按鈕文字
          "開啟自評表"
        );
      });
    </script>
    <script type="module">
      import * as THREE from "./build/three.module.js";
      import { GUI } from "./jsm/libs/dat.gui.module.js";
      import { OrbitControls } from "./jsm/controls/OrbitControls.js";
      import { OutlineEffect } from "./jsm/effects/OutlineEffect.js";
      import { MMDLoader } from "./jsm/loaders/MMDLoader.js";
      import { MMDAnimationHelper } from "./jsm/animation/MMDAnimationHelper.js";

      let scene, renderer, effect;
      let mesh, helper;
      let SCREEN_WIDTH = window.innerWidth;
      let SCREEN_HEIGHT = window.innerHeight;
      let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
      let frustumSize = 4;
      let camera, camera2, camera3, camera4, camera5;
      let modelOrder = 0;
      let modelList;
      let modelJson = "model_data.json";
      let Lines = [];
      let LinesMirror = [];
      let data = [];
      //判斷哪一顆眼睛
      let eyeCount = 0;
      //線段的一半長
      let lineHalfLength = 0.6;

      let lineColors = [
        { h: 0xe60000, v: 0xffd700 },
        { h: 0x00ff00, v: 0x0033ff },
      ];

      //滑鼠偵測用途
      let mouseDown = false;
      let mouseX = 0;
      let mouseY = 0;

      //眼睛在模型中的位置
      let rEyeIndex;
      let lEyeIndex;

      //眼睛移動參數
      //判斷左右眼
      let RLeye;
      //R:移動 R:右邊 X:座標X
      let r1 = {
        rx: -8,
        ry: 0,
        lx: -8,
        ly: 0,
      };
      let r2 = {
        rx: 11.4,
        ry: 0,
        lx: 11.4,
        ly: 0,
      };
      let r3 = {
        rx: 0,
        ry: -8,
        lx: 0,
        ly: -12.6,
      };
      let r4 = {
        rx: 0,
        ry: 12.6,
        lx: 0,
        ly: 8,
      };

      let RRX = 0;
      let RRY = 0;
      let RLX = 0;
      let RLY = 0;

      Ammo().then(function (AmmoLib) {
        Ammo = AmmoLib;

        init();
        animate();
      });

      function readTextFile(file, callback) {
        var rawFile = new XMLHttpRequest();
        rawFile.overrideMimeType("application/json");
        rawFile.open("GET", file, true);
        rawFile.onreadystatechange = function () {
          if (rawFile.readyState === 4 && rawFile.status == "200") {
            callback(rawFile.responseText);
          }
        };
        rawFile.send(null);
      }

      function init() {
        const container = document.createElement("div");
        document.body.appendChild(container);
        camera = new THREE.OrthographicCamera(
          (0.5 * frustumSize * aspect) / -4,
          (0.5 * frustumSize * aspect) / 4,
          frustumSize / 4,
          frustumSize / -4,
          0.1,
          1000
        );
        camera2 = new THREE.OrthographicCamera(
          (0.25 * frustumSize * aspect) / -2,
          (0.25 * frustumSize * aspect) / 2,
          (0.5 * frustumSize) / 2,
          (0.5 * frustumSize) / -2,
          0.1,
          1000
        );
        camera3 = new THREE.OrthographicCamera(
          (0.25 * frustumSize * aspect) / -2,
          (0.25 * frustumSize * aspect) / 2,
          (0.5 * frustumSize) / 2,
          (0.5 * frustumSize) / -2,
          0.1,
          1000
        );
        camera4 = new THREE.OrthographicCamera(
          (0.25 * frustumSize * aspect) / -2,
          (0.25 * frustumSize * aspect) / 2,
          (0.5 * frustumSize) / 2,
          (0.5 * frustumSize) / -2,
          0.1,
          1000
        );
        camera5 = new THREE.OrthographicCamera(
          (0.25 * frustumSize * aspect) / -2,
          (0.25 * frustumSize * aspect) / 2,
          (0.5 * frustumSize) / 2,
          (0.5 * frustumSize) / -2,
          0.1,
          1000
        );

        // scene

        scene = new THREE.Scene();
        const ambient = new THREE.AmbientLight(0x666666);
        scene.add(ambient);

        const directionalLight = new THREE.DirectionalLight(0x887766);
        directionalLight.position.set(-1, 1, 1).normalize();
        scene.add(directionalLight);

        //render

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        renderer.autoClear = false;
        effect = new OutlineEffect(renderer);

        modelList = ["kizunaai", "『天宮こころ(Kokoro Amamiya)』", "物述有栖"];
        LoadMMD(modelOrder);

        //
        readTextFile(modelJson, function (json) {
          data = JSON.parse(json)["modellist"];
          initLines();
          console.log(data);
        });

        window.addEventListener("resize", onWindowResize);
        window.addEventListener("keydown", onKeyDown);
        window.addEventListener("mousedown", onMouseDown);
        window.addEventListener("mouseup", onMouseUp);
        window.addEventListener("mousemove", onMouseMove);
        // window.addEventListener("mousedown", onMouseDown);
        //鏡頭控制
      }

      function initLines() {
        for (let i = 0; i < 3; i++) {
          Lines.push(eyeLines(i, "R"));
          LinesMirror.push(eyeLines(i, "L"));
        }
      }

      function eyeLines(ilc, eye) {
        let isHorizontal;
        let downLinePositin = {
          x: data[ilc].line_locationx_1,
          y: data[ilc].line_locationy_1,
        };
        let leftLinePositin = {
          x: data[ilc].line_locationx_2,
          y: data[ilc].line_locationy_2,
        };
        let upLinePositin = {
          x: data[ilc].line_locationx_3,
          y: data[ilc].line_locationy_3,
        };
        let rightLinePositin = {
          x: data[ilc].line_locationx_4,
          y: data[ilc].line_locationy_4,
        };

        let line = null;
        let lines = [];

        //間隔距離
        let dx = (rightLinePositin.x - leftLinePositin.x) / 8;
        let dy = (upLinePositin.y - downLinePositin.y) / 4;
        let point = { x: 0, y: 0, z: 31 };

        if (eye == "R") {
          //畫水平線
          isHorizontal = true;
          point.x = downLinePositin.x;
          for (let i = 0; i <= 4; i++) {
            point.y = downLinePositin.y + dy * i;
            line = createLine(point, lineColors[0].h, isHorizontal);
            lines.push(line);
          }

          //畫垂直線
          isHorizontal = false;
          point.y = leftLinePositin.y;
          for (let i = 0; i <= 8; i++) {
            point.x = leftLinePositin.x + dx * i;
            line = createLine(point, lineColors[0].v, isHorizontal);
            lines.push(line);
          }
        } else if (eye == "L") {
          //畫水平線
          isHorizontal = true;
          point.x = -downLinePositin.x;
          for (let i = 0; i <= 4; i++) {
            point.y = downLinePositin.y + dy * i;
            line = createLine(point, lineColors[0].h, isHorizontal);
            lines.push(line);
          }

          //畫垂直線
          isHorizontal = false;
          point.y = leftLinePositin.y;
          for (let i = 0; i <= 8; i++) {
            point.x = -(leftLinePositin.x + dx * i);
            line = createLine(point, lineColors[0].v, isHorizontal);
            lines.push(line);
          }
        }

        return lines;
      }

      function rmLines() {
        Lines[modelOrder].forEach(function (line) {
          scene.remove(line);
        });
      }
      function createLine(point, color, isHorizontal) {
        let linePoints;
        if (isHorizontal) {
          linePoints = [
            new THREE.Vector3(point.x - lineHalfLength, point.y, 2),
            new THREE.Vector3(point.x + lineHalfLength, point.y, 2),
          ];
        } else {
          linePoints = [
            new THREE.Vector3(point.x, point.y - lineHalfLength),
            new THREE.Vector3(point.x, point.y + lineHalfLength),
          ];
        }
        return new THREE.Line(
          new THREE.BufferGeometry().setFromPoints(linePoints),
          new THREE.LineBasicMaterial({ color: color })
        );
      }

      function cameraPos(modelOrder) {
        if (modelOrder == 0) {
          camera.position.x = -1;
          camera.position.y = 8.1;
          camera.position.z = 30;
          camera2.position.x = -0.2;
          camera2.position.y = 8.1;
          camera2.position.z = 30;
          camera3.position.x = -0.2;
          camera3.position.y = 8.1;
          camera3.position.z = 30;
          camera4.position.x = -0.2;
          camera4.position.y = 8.1;
          camera4.position.z = 30;
          camera5.position.x = -0.2;
          camera5.position.y = 8.1;
          camera5.position.z = 30;
        } else if (modelOrder == 1) {
          camera.position.x = -1;
          camera.position.y = 5.5;
          camera.position.z = 30;
          camera2.position.x = -0.2;
          camera2.position.y = 5.5;
          camera2.position.z = 30;
          camera3.position.x = -0.2;
          camera3.position.y = 5.5;
          camera3.position.z = 30;
          camera4.position.x = -0.2;
          camera4.position.y = 5.5;
          camera4.position.z = 30;
          camera5.position.x = -0.2;
          camera5.position.y = 5.5;
          camera5.position.z = 30;
        } else if (modelOrder == 2) {
          camera.position.x = -1;
          camera.position.y = 8.1;
          camera.position.z = 30;
          camera2.position.x = -0.2;
          camera2.position.y = 8.1;
          camera2.position.z = 30;
          camera3.position.x = -0.2;
          camera3.position.y = 8.1;
          camera3.position.z = 30;
          camera4.position.x = -0.2;
          camera4.position.y = 8.1;
          camera4.position.z = 30;
          camera5.position.x = -0.2;
          camera5.position.y = 8.1;
          camera5.position.z = 30;
        }
      }
      //鍵盤
      function onKeyDown(e) {
        if (e.key == "a" || e.key == "A") {
          scene.remove(mesh);
          rmLines();
          modelOrder--;
          if (modelOrder < 0) {
            modelOrder = modelList.length - 1;
          }
          LoadMMD(modelOrder);
        } else if (e.key == "d" || e.key == "D") {
          scene.remove(mesh);
          rmLines();
          modelOrder++;
          if (modelOrder == modelList.length) {
            modelOrder = 0;
          }
          LoadMMD(modelOrder);
        } else if (e.key == "1") {
          //左眼
          RLeye = "L";
          eyeCount--;
          MirrorEye();
          if (eyeCount < 0) {
            eyeCount = 0;
          }
        } else if (e.key == "2") {
          //右眼
          RLeye = "R";
          eyeCount++;
          MirrorEye();
          if (eyeCount > 7) {
            eyeCount = 7;
            MirrorEye();
          }
        } else if (e.key == "q" || e.key == "Q") {
          if (eyeCount == 0) {
            r1.lx = r1.rx;
            r1.ly = -r1.ry;
            eyeCount++;
          } else if (eyeCount == 2) {
            r2.lx = r2.rx;
            r2.ly = -r2.ry;
            eyeCount++;
          } else if (eyeCount == 4) {
            r4.lx = r3.rx;
            r4.ly = -r3.ry;
            eyeCount = 7;
          } else if (eyeCount == 6) {
            r3.lx = r4.rx;
            r3.ly = -r4.ry;
            eyeCount--;
          }
        }
      }

      function MirrorEye() {
        if (eyeCount % 2 == 0) {
          camera.position.x = -1;
        } else {
          camera.position.x = 1;
        }
      }

      function LoadMMD(modelOrder) {
        // model
        function onProgress(xhr) {
          if (xhr.lengthComputable) {
            const percentComplete = (xhr.loaded / xhr.total) * 100;
            console.log(Math.round(percentComplete, 2) + "% downloaded");
          }
        }

        helper = new MMDAnimationHelper();

        const loader = new MMDLoader();

        let modelFile =
          "models/mmd/" +
          modelList[modelOrder] +
          "/" +
          modelList[modelOrder] +
          ".pmx";

        loader.load(
          modelFile,
          function (object) {
            cameraPos(modelOrder);
            mesh = object;
            if (modelOrder < 2) {
              mesh.position.y = -10;
              mesh.position.z = -5;
            } else {
              mesh.position.y = -6.3;
              mesh.position.z = -5;
            }

            // clickObjects.push(mesh);
            scene.add(mesh);
            findEyeIndex();
            //更新線
            addNewLine();
          },
          onProgress,
          null
        );
      }
      function findEyeIndex() {
        for (let i = 0; i < mesh.skeleton.bones.length; i++) {
          if (mesh.skeleton.bones[i].name == "左目") {
            lEyeIndex = i;
            console.log("左眼參數: " + lEyeIndex);
          } else if (mesh.skeleton.bones[i].name == "右目") {
            rEyeIndex = i;
          }
        }
      }
      function addNewLine() {
        Lines[modelOrder].forEach(function (line) {
          scene.add(line);
        });
        LinesMirror[modelOrder].forEach(function (line) {
          scene.add(line);
        });
      }

      function onWindowResize() {
        SCREEN_WIDTH = window.innerWidth;
        SCREEN_HEIGHT = window.innerHeight;
        aspect = SCREEN_WIDTH / SCREEN_HEIGHT;

        effect.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

        camera.left = (0.5 * frustumSize * aspect) / -2;
        camera.right = (0.5 * frustumSize * aspect) / 2;
        camera.top = frustumSize / 2;
        camera.bottom = -frustumSize / 2;
        camera.updateProjectionMatrix();

        camera2.left = (0.25 * frustumSize * aspect) / -2;
        camera2.right = (0.25 * frustumSize * aspect) / 2;
        camera2.top = (0.5 * frustumSize) / 2;
        camera2.bottom = (-0.5 * frustumSize) / 2;
        camera2.updateProjectionMatrix();

        camera3.left = (0.25 * frustumSize * aspect) / -2;
        camera3.right = (0.25 * frustumSize * aspect) / 2;
        camera3.top = (0.5 * frustumSize) / 2;
        camera3.bottom = (-0.5 * frustumSize) / 2;
        camera3.updateProjectionMatrix();

        camera4.left = (0.25 * frustumSize * aspect) / -2;
        camera4.right = (0.25 * frustumSize * aspect) / 2;
        camera4.top = (0.5 * frustumSize) / 2;
        camera4.bottom = (-0.5 * frustumSize) / 2;
        camera4.updateProjectionMatrix();

        camera5.left = (0.25 * frustumSize * aspect) / -2;
        camera5.right = (0.25 * frustumSize * aspect) / 2;
        camera5.top = (0.5 * frustumSize) / 2;
        camera5.bottom = (-0.5 * frustumSize) / 2;
        camera5.updateProjectionMatrix();
      }

      //滑鼠
      function onMouseDown(evt) {
        evt.preventDefault();
        mouseDown = true;
        mouseX = evt.clientX;
        mouseY = evt.clientY;
      }
      function onMouseUp(evt) {
        evt.preventDefault();
        mouseDown = false;
      }
      function onMouseMove(evt) {
        if (!mouseDown) {
          return;
        }
        evt.preventDefault();
        let deltaX = evt.clientX - mouseX;
        let deltaY = evt.clientY - mouseY;
        mouseX = evt.clientX;
        mouseY = evt.clientY;
        rotateEye(deltaX, deltaY);
      }
      function rotateEye(deltaX, deltaY) {
        if (mouseDown) {
          switch (eyeCount) {
            case 0:
              r1.rx += deltaY / 10;
              r1.ry += deltaX / 10;
              break;
            case 1:
              r1.lx += deltaY / 10;
              r1.ly += deltaX / 10;
              break;
            case 2:
              r2.rx += deltaY / 10;
              r2.ry += deltaX / 10;
              break;
            case 3:
              r2.lx += deltaY / 10;
              r2.ly += deltaX / 10;
              break;
            case 4:
              r3.rx += deltaY / 10;
              r3.ry += deltaX / 10;
              break;
            case 5:
              r3.lx += deltaY / 10;
              r3.ly += deltaX / 10;
              break;
            case 6:
              r4.rx += deltaY / 10;
              r4.ry += deltaX / 10;
              break;
            case 7:
              r4.lx += deltaY / 10;
              r4.ly += deltaX / 10;
              break;

            default:
              break;
          }
        }
      }
      function saveJson(modelOrder) {
        let OutputJson = [];
        OutputJson.push({
          modelName: data[modelOrder].modelPath,
          modelEyeRotationAngles: {
            Right_X_negative_angle: r1.ry,
            Left_X_negative_angle: r1.ly,
            Right_X_positive_angle: r2.ry,
            Left_X_positive_angle: r2.ly,
            Right_Y_negative_angle: r3.rx,
            Left_Y_negative_angle: r3.lx,
            Right_Y_positive_angle: r4.rx,
            Left_Y_positive_angle: r4.lx,
          },
        });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(
          new Blob([JSON.stringify(OutputJson, null, 2)], {
            type: "json/plain",
          })
        );
        a.setAttribute("download", "OutputJson.json");
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }
      function animate() {
        requestAnimationFrame(animate);
        render();
      }

      function moveLine(i, LR) {
        if (LR == "R") {
          Lines[modelOrder].forEach(function (line) {
            line.position.x = i;
          });
        } else if (LR == "L") {
          LinesMirror[modelOrder].forEach(function (line) {
            line.position.x = i;
          });
        } else if (LR == "LR") {
          Lines[modelOrder].forEach(function (line) {
            line.position.x = i;
          });
          LinesMirror[modelOrder].forEach(function (line) {
            line.position.x = i;
          });
        }
      }

      function render() {
        effect.clear();
        if (!mesh) return;
        Lines[modelOrder].forEach(function (line) {
          line.position.x = 0;
        });
        LinesMirror[modelOrder].forEach(function (line) {
          line.position.x = 0;
        });
        switch (eyeCount) {
          case 0:
            mesh.skeleton.bones[rEyeIndex].rotation.x =
              THREE.MathUtils.degToRad(r1.rx);
            mesh.skeleton.bones[rEyeIndex].rotation.y =
              THREE.MathUtils.degToRad(r1.ry);
            break;
          case 1:
            mesh.skeleton.bones[lEyeIndex].rotation.x =
              THREE.MathUtils.degToRad(r1.lx);
            mesh.skeleton.bones[lEyeIndex].rotation.y =
              THREE.MathUtils.degToRad(r1.ly);
            break;
          case 2:
            mesh.skeleton.bones[rEyeIndex].rotation.x =
              THREE.MathUtils.degToRad(r2.rx);
            mesh.skeleton.bones[rEyeIndex].rotation.y =
              THREE.MathUtils.degToRad(r2.ry);
            break;
          case 3:
            mesh.skeleton.bones[lEyeIndex].rotation.x =
              THREE.MathUtils.degToRad(r2.lx);
            mesh.skeleton.bones[lEyeIndex].rotation.y =
              THREE.MathUtils.degToRad(r2.ly);
            break;
          case 4:
            mesh.skeleton.bones[rEyeIndex].rotation.x =
              THREE.MathUtils.degToRad(r3.rx);
            mesh.skeleton.bones[rEyeIndex].rotation.y =
              THREE.MathUtils.degToRad(r3.ry);
            break;
          case 5:
            mesh.skeleton.bones[lEyeIndex].rotation.x =
              THREE.MathUtils.degToRad(r3.lx);
            mesh.skeleton.bones[lEyeIndex].rotation.y =
              THREE.MathUtils.degToRad(r3.ly);
            break;
          case 6:
            mesh.skeleton.bones[rEyeIndex].rotation.x =
              THREE.MathUtils.degToRad(r4.rx);
            mesh.skeleton.bones[rEyeIndex].rotation.y =
              THREE.MathUtils.degToRad(r4.ry);
            break;
          case 7:
            mesh.skeleton.bones[lEyeIndex].rotation.x =
              THREE.MathUtils.degToRad(r4.lx);
            mesh.skeleton.bones[lEyeIndex].rotation.y =
              THREE.MathUtils.degToRad(r4.ly);
            break;

          default:
            break;
        }

        effect.setViewport(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
        effect.render(scene, camera);

        moveLine(100, "LR");

        if (eyeCount == 0) {
          moveLine(0, "R");
        }
        if (eyeCount == 1) {
          moveLine(0, "L");
        }
        mesh.skeleton.bones[rEyeIndex].rotation.x = THREE.MathUtils.degToRad(
          r1.rx
        );
        mesh.skeleton.bones[lEyeIndex].rotation.x = THREE.MathUtils.degToRad(
          r1.lx
        );
        mesh.skeleton.bones[rEyeIndex].rotation.y = THREE.MathUtils.degToRad(
          r1.ry
        );
        mesh.skeleton.bones[lEyeIndex].rotation.y = THREE.MathUtils.degToRad(
          r1.ly
        );
        effect.setViewport(
          SCREEN_WIDTH / 2,
          SCREEN_HEIGHT / 2,
          SCREEN_WIDTH / 4,
          SCREEN_HEIGHT / 2
        );
        effect.render(scene, camera2);
        moveLine(100, "LR");

        if (eyeCount == 2) {
          moveLine(0, "R");
        }
        if (eyeCount == 3) {
          moveLine(0, "L");
        }

        mesh.skeleton.bones[rEyeIndex].rotation.x = THREE.MathUtils.degToRad(
          r2.rx
        );
        mesh.skeleton.bones[lEyeIndex].rotation.x = THREE.MathUtils.degToRad(
          r2.lx
        );
        mesh.skeleton.bones[rEyeIndex].rotation.y = THREE.MathUtils.degToRad(
          r2.ry
        );
        mesh.skeleton.bones[lEyeIndex].rotation.y = THREE.MathUtils.degToRad(
          r2.ly
        );
        effect.setViewport(
          SCREEN_WIDTH / 2 + SCREEN_WIDTH / 4,
          SCREEN_HEIGHT / 2,
          SCREEN_WIDTH / 4,
          SCREEN_HEIGHT / 2
        );
        effect.render(scene, camera3);
        moveLine(100, "LR");

        if (eyeCount == 4) {
          moveLine(0, "R");
        }
        if (eyeCount == 5) {
          moveLine(0, "L");
        }

        mesh.skeleton.bones[rEyeIndex].rotation.x = THREE.MathUtils.degToRad(
          r3.rx
        );
        mesh.skeleton.bones[lEyeIndex].rotation.x = THREE.MathUtils.degToRad(
          r3.lx
        );
        mesh.skeleton.bones[rEyeIndex].rotation.y = THREE.MathUtils.degToRad(
          r3.ry
        );
        mesh.skeleton.bones[lEyeIndex].rotation.y = THREE.MathUtils.degToRad(
          r3.ly
        );
        effect.setViewport(
          SCREEN_WIDTH / 2,
          0,
          SCREEN_WIDTH / 4,
          SCREEN_HEIGHT / 2
        );
        effect.render(scene, camera4);
        moveLine(100, "LR");

        if (eyeCount == 6) {
          moveLine(0, "R");
        }
        if (eyeCount == 7) {
          moveLine(0, "L");
        }

        mesh.skeleton.bones[rEyeIndex].rotation.x = THREE.MathUtils.degToRad(
          r4.rx
        );
        mesh.skeleton.bones[lEyeIndex].rotation.x = THREE.MathUtils.degToRad(
          r4.lx
        );
        mesh.skeleton.bones[rEyeIndex].rotation.y = THREE.MathUtils.degToRad(
          r4.ry
        );
        mesh.skeleton.bones[lEyeIndex].rotation.y = THREE.MathUtils.degToRad(
          r4.ly
        );
        effect.setViewport(
          SCREEN_WIDTH / 2 + SCREEN_WIDTH / 4,
          0,
          SCREEN_WIDTH / 4,
          SCREEN_HEIGHT / 2
        );
        effect.render(scene, camera5);
      }
    </script>
  </body>
</html>
